% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Embryo Pre-processing Documentation}
\date{March 12, 2015}
\release{0.0.1}
\author{James Brown}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{EmbryoPreprocess module}
\label{EmbryoPreprocess::doc}\label{EmbryoPreprocess:module-EmbryoPreprocess}\label{EmbryoPreprocess:welcome-to-embryo-pre-processing-s-documentation}\label{EmbryoPreprocess:embryopreprocess-module}\index{EmbryoPreprocess (module)}
Search for downloaded embryo media (OPT/uCT) and pre-process it accordingly for viewing in Internet Embryo Viewer (IEV)

Class instances are initialised by passing in a config (.yaml) file, which contains the hostname (HOST),
username (USER) and password (PASS) required to connect to the database. This allows for easy switching between
``prince'' and ``live''.

To begin pre-processing, the run() method must be called. Upon establishing a successful connection to the database,
the program queries phenodcc\_media.media\_file, finding all valid recon media:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{n}{cid}\PYG{p}{,} \PYG{n}{lid}\PYG{p}{,} \PYG{n}{gid}\PYG{p}{,} \PYG{n}{sid}\PYG{p}{,} \PYG{n}{pid}\PYG{p}{,} \PYG{n}{qid}\PYG{p}{,} \PYG{n}{genotype}\PYG{p}{.}\PYG{n}{genotype}\PYG{p}{,} \PYG{n}{gene\PYGZus{}symbol}\PYG{p}{,} \PYG{n}{measurement\PYGZus{}id}\PYG{p}{,} \PYG{n}{url}\PYG{p}{,} \PYG{n}{checksum}\PYG{p}{,} \PYG{n}{extension}\PYG{p}{,} \PYG{n}{metadataGroup}

\PYG{k}{FROM} \PYG{n}{phenodcc\PYGZus{}media}\PYG{p}{.}\PYG{n}{media\PYGZus{}file}\PYG{p}{,} \PYG{n}{phenodcc\PYGZus{}overviews}\PYG{p}{.}\PYG{n}{genotype}\PYG{p}{,} \PYG{n}{phenodcc\PYGZus{}embryo}\PYG{p}{.}\PYG{n}{file\PYGZus{}extension}\PYG{p}{,} \PYG{n}{phenodcc\PYGZus{}overviews}\PYG{p}{.}\PYG{n}{measurements\PYGZus{}performed}

\PYG{k}{WHERE}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} get the qid for the recon parameters}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} IMPC\PYGZus{}EOL\PYGZus{}001\PYGZus{}001 OPT E9.5}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} IMPC\PYGZus{}EMO\PYGZus{}001\PYGZus{}001 uCT E14.5/E15.5}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} IMPC\PYGZus{}EMA\PYGZus{}001\PYGZus{}001 uCT E18.5}
\PYG{n}{qid} \PYG{o}{=} \PYG{p}{(}\PYG{k}{select} \PYG{n}{impress}\PYG{p}{.}\PYG{n}{parameter}\PYG{p}{.}\PYG{n}{parameter\PYGZus{}id} \PYG{k}{from} \PYG{n}{impress}\PYG{p}{.}\PYG{n}{parameter} \PYG{k}{where} \PYG{n}{parameter}\PYG{p}{.}\PYG{n}{parameter\PYGZus{}key} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}IMPC\PYGZus{}EMO\PYGZus{}001\PYGZus{}001\PYGZdq{}} \PYG{p}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} join with measurements\PYGZus{}performed to get the latest active and valid data}
\PYG{k}{and} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{measurements\PYGZus{}performed}\PYG{p}{.}\PYG{n}{measurement\PYGZus{}id}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} join with genotype to get the colony id and gene\PYGZus{}symbol}
\PYG{k}{AND} \PYG{n}{genotype}\PYG{p}{.}\PYG{n}{genotype\PYGZus{}id} \PYG{o}{=} \PYG{n}{gid}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} join with extension to get the extension}
\PYG{k}{AND} \PYG{n}{extension\PYGZus{}id} \PYG{o}{=} \PYG{n}{file\PYGZus{}extension}\PYG{p}{.}\PYG{n}{id}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} recon has been downloaded and skipped tiling}
\PYG{k}{AND} \PYG{p}{(}\PYG{p}{(}\PYG{n}{phase\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{or} \PYG{p}{(}\PYG{n}{phase\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{AND} \PYG{n}{checksum} \PYG{k}{IS} \PYG{k}{NOT} \PYG{n+no}{null}

\PYG{k}{LIMIT} \PYG{l+m+mi}{10000000}
\end{Verbatim}

Subject to certain constraints, valid data is added to a pre-processing list which is subsequently handled by the process\_recons() method.
\begin{quote}\begin{description}
\item[{Author}] \leavevmode
\emph{James Brown}

\item[{Organization}] \leavevmode
Medical Research Council (MRC) Harwell, Oxfordshire, UK

\item[{Version}] \leavevmode
0.0.1

\end{description}\end{quote}


\section{Requirements}
\label{EmbryoPreprocess:requirements}\begin{itemize}
\item {} 
\href{http://www.python.org}{Python 2.7}

\item {} 
\href{http://www.numpy.org}{Numpy 1.8.2}

\item {} 
\href{http://pyyaml.org/}{PyYAML 3.11}

\item {} 
\href{http://mysql-python.sourceforge.net/MySQLdb.html}{MySQLdb 1.2.3}

\item {} 
\href{http://www.simpleitk.org/}{SimpleITK 0.8.1}

\end{itemize}


\section{Examples}
\label{EmbryoPreprocess:examples}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ep} \PYG{o}{=} \PYG{n}{EmbryoPreprocess}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/local/folder/IMPC\PYGZus{}media}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{phenodcc\PYGZus{}embryo.preprocessed}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{db\PYGZus{}connect.yaml}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ep}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}
\index{EmbryoPreprocess (class in EmbryoPreprocess)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess}\pysiglinewithargsret{\strong{class }\code{EmbryoPreprocess.}\bfcode{EmbryoPreprocess}}{\emph{base\_path}, \emph{embryo\_table}, \emph{config\_file}}{}
Bases: \code{object}

The \_\_init\_\_ initialises a number of class attributes, and parses the .yaml config file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{config\_file} -- path to .yaml containing database connection credentials.

\item {} 
\textbf{base\_path} -- path where the embryo `src' and `emb' directories are located

\item {} 
\textbf{embryo\_table} -- name of the table where embryo pre-processing rows are to be added

\end{itemize}

\end{description}\end{quote}
\index{db\_connect() (EmbryoPreprocess.EmbryoPreprocess method)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess.db_connect}\pysiglinewithargsret{\bfcode{db\_connect}}{}{}
The db\_connect method attempts to connect to a database using the credentials in the specified .yaml file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
MySQLdb connect object if successful, or None if connection fails

\end{description}\end{quote}

\end{fulllineitems}

\index{db\_disconnect() (EmbryoPreprocess.EmbryoPreprocess method)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess.db_disconnect}\pysiglinewithargsret{\bfcode{db\_disconnect}}{}{}
The db\_disconnect method attempts to disconnect from the database, and is called at the end of processing.
Raises an exception upon failure (i.e. if the connection has already been closed).

\end{fulllineitems}

\index{get\_mip() (EmbryoPreprocess.EmbryoPreprocess method)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess.get_mip}\pysiglinewithargsret{\bfcode{get\_mip}}{\emph{in\_path}, \emph{out\_dir}}{}
The get\_mip method generates three maximum intensity projections (MIP) for visual QC purposes.

MIPs are generated from the downscaled image data, so the whole image can be loaded into memory for ease. The
resulting images are written to disk in .png format.

\end{fulllineitems}

\index{process\_recons() (EmbryoPreprocess.EmbryoPreprocess method)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess.process_recons}\pysiglinewithargsret{\bfcode{process\_recons}}{}{}
The process\_recons method loops through the pre-processing list, and attempts to process each recon in turn.

For each recon in the pre-processing list, it is first decompressed (if necessary) according to its file
extension. Unfortunately, we do not know what image format the data will be. To overcome this, the program will
attempt to open the file using each of the valid file readers in turn.

If the file is successfully opened, the pixel size extracted from the database:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{phenodcc\PYGZus{}overviews}\PYG{p}{.}\PYG{n}{metadata\PYGZus{}group\PYGZus{}to\PYGZus{}values}
    \PYG{k}{WHERE} \PYG{n}{metadata\PYGZus{}group} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}REPLACE\PYGZdl{}\PYGZdq{}}
\end{Verbatim}

The image data is then rescaled to pre-specified image resolutions, writing the results to disk as
NRRD files. In addition to the rescaled images, three orthogonal maximum intensity projection (MIP) are
generated for visual QC purposes (for the moment, these are written to the IMPC\_media/emb/... directory)

The three possible outcomes of the pre-processing job are as follows:
\begin{enumerate}
\item {} 
Successfully read and resample image data (status\_id 1)

\item {} 
Failed to read image data, presumably due to an invalid file extension (status\_id 2)

\item {} 
Error when resampling image data (status\_id 3)

\end{enumerate}

Finally, the status ID, extension ID and pixel size are updated in the embryo pre-processing table:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{UPDATE} \PYG{n}{phenodcc\PYGZus{}embryo}\PYG{p}{.}\PYG{n}{preprocessed} \PYG{k+kt}{SET} \PYG{n}{status\PYGZus{}id}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{extension\PYGZus{}id}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{pixelsize}\PYG{o}{=}\PYG{l+m+mi}{13}\PYG{p}{.}\PYG{l+m+mi}{59} \PYG{k}{WHERE} \PYG{n}{url}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}/the/url/123456.bz2\PYGZdq{}}
\end{Verbatim}

\end{fulllineitems}

\index{query\_database() (EmbryoPreprocess.EmbryoPreprocess method)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess.query_database}\pysiglinewithargsret{\bfcode{query\_database}}{\emph{sql}, \emph{replacement=None}}{}
The query\_database method executes arbitrary queries and returns any results as dictionary lists.

Input queries can be either strings or SQL files. If a replacement is specified, the \$REPLACE\$ wildcard will be
replaced with it. The query is then executed and committed, raising an exception upon failure. If there are rows
to be returned, the resulting data is parsed and returned as a list of dictionaries that can be referenced
by column name for convenience.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sql} -- either a string containing an SQL query, or a path to an SQL file

\item {} 
\textbf{replacement} -- optional argument for SQL files, \$REPLACE\$ wildcard is replaced with the specified string

\end{itemize}

\item[{Returns}] \leavevmode
a list of dictionaries if there were rows returned, otherwise None

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (EmbryoPreprocess.EmbryoPreprocess method)}

\begin{fulllineitems}
\phantomsection\label{EmbryoPreprocess:EmbryoPreprocess.EmbryoPreprocess.run}\pysiglinewithargsret{\bfcode{run}}{}{}
The run method queries the phenodcc\_media.media\_file table, identifying those that require pre-processing.

The method firsts attempts to connect to the database. If this connection fails, an exception is raised and the
program terminates. If the connection is successful, the program queries phenodcc\_media.media\_file for media
submitted for each of the three ``embryo reconstruction'' parameters; IMPC\_EOL\_001\_001 (OPT E9.5),
IMPC\_EMO\_001\_001 (uCT E14.5/15.5) and IMPC\_EMA\_001\_001 (uCT E18.5).

For each of the rows returned, its unique URL is used to determine where it has already processed:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT} \PYG{o}{*} \PYG{k}{FROM} \PYG{n}{phenodcc\PYGZus{}embryo}\PYG{p}{.}\PYG{n}{preprocessed} \PYG{k}{WHERE} \PYG{n}{url} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}/the/url/123456.bz2\PYGZdq{}}
\end{Verbatim}
\begin{description}
\item[{If URL already exists in phenodcc\_embryo.preprocessed:}] \leavevmode\begin{enumerate}
\item {} 
Check its status ID and extension ID

\item {} 
If status\_id != 1 (success), add job to the pre-processing list

\item {} 
Otherwise, update its metadataGroup and measurement\_id.

\end{enumerate}

\item[{Otherwise:}] \leavevmode\begin{enumerate}
\item {} 
Create a new row in the pre-processing table

\item {} 
Add job to the pre-processing list.

\end{enumerate}

\end{description}
\end{quote}

Once all of the parameters have been searched against, the process\_recons method is called.

\end{fulllineitems}


\end{fulllineitems}



\chapter{SliceGenerator module}
\label{SliceGenerator:module-SliceGenerator}\label{SliceGenerator:slicegenerator-module}\label{SliceGenerator::doc}\index{SliceGenerator (module)}
The SliceGenerator class is an ``abstract'' superclass designed to be extended for specific file formats.

Subclasses call the super constructor and override the slices() that yields image slices when used as a generator. The
class should also override the dtype() and shape() methods accordingly.

Instances of a subclass should be initialised by passing a valid file path as an argument. Slices may then be generated
using a for-loop, calling the slices() method on the generator object.


\section{Requirements}
\label{SliceGenerator:requirements}\begin{itemize}
\item {} 
\href{http://www.h5py.org/}{h5py}

\item {} 
\href{http://www.numpy.org}{Numpy 1.8.2}

\item {} 
\href{https://github.com/waveform80/ctutils}{ctutils 0.2}

\end{itemize}


\section{Examples}
\label{SliceGenerator:examples}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{SliceGenerator} \PYG{k+kn}{import} \PYG{n}{NrrdSliceGenerator}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{gen} \PYG{o}{=} \PYG{n}{NrrdSliceGenerator}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path/to/file.nrrd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{gen}\PYG{o}{.}\PYG{n}{slices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}  \PYG{c}{\PYGZsh{} do something with the slice}
\end{Verbatim}
\index{MincSliceGenerator (class in SliceGenerator)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.MincSliceGenerator}\pysiglinewithargsret{\strong{class }\code{SliceGenerator.}\bfcode{MincSliceGenerator}}{\emph{recon}}{}
Bases: {\hyperref[SliceGenerator:SliceGenerator.SliceGenerator]{\code{SliceGenerator.SliceGenerator}}}

The MincSliceGenerator class extends SliceGenerator, yielding slices from a single MINC (Medical Image NetCDF)
file.

MINC files (.mnc) are based on the Hierarchical Data (HDF5) Format, and so they are currently handled by the h5py
module (\href{https://github.com/h5py/h5py}{https://github.com/h5py/h5py}).
\index{dtype() (SliceGenerator.MincSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.MincSliceGenerator.dtype}\pysiglinewithargsret{\bfcode{dtype}}{}{}
Overrides the superclass to return the data type of the MINC file i.e. 8 bit/16 bit.

\end{fulllineitems}

\index{shape() (SliceGenerator.MincSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.MincSliceGenerator.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
Overrides the superclass to return the shape of the MINC file.

\end{fulllineitems}

\index{slices() (SliceGenerator.MincSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.MincSliceGenerator.slices}\pysiglinewithargsret{\bfcode{slices}}{\emph{start=0}}{}
Slices are yielded one slice at a time from the memory mapped numpy array

\end{fulllineitems}


\end{fulllineitems}

\index{NrrdSliceGenerator (class in SliceGenerator)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.NrrdSliceGenerator}\pysiglinewithargsret{\strong{class }\code{SliceGenerator.}\bfcode{NrrdSliceGenerator}}{\emph{recon}}{}
Bases: {\hyperref[SliceGenerator:SliceGenerator.SliceGenerator]{\code{SliceGenerator.SliceGenerator}}}

The NrrdSliceGenerator class extends SliceGenerator, yielding slices from a single NRRD (Nearly Raw Raster Data)
file.

NRRDs are the most likely file type to be received at the DCC, especially for those centres that have adopted HARP.
This generator has gone through several iterations, and now relies on Utah Nrrd Utilities (unu) by teem
(\href{http://teem.sourceforge.net/index.html}{http://teem.sourceforge.net/index.html}).
\index{dtype() (SliceGenerator.NrrdSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.NrrdSliceGenerator.dtype}\pysiglinewithargsret{\bfcode{dtype}}{}{}
Overrides the superclass to return the data type of the NRRD file i.e. 8 bit/16 bit.

\end{fulllineitems}

\index{parse\_header() (SliceGenerator.NrrdSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.NrrdSliceGenerator.parse_header}\pysiglinewithargsret{\bfcode{parse\_header}}{\emph{hdr}}{}
The parse\_header method reads a NRRD header and extracts the data type, shape and encoding of the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{hdr} -- path to a header (.hdr) file

\end{description}\end{quote}

\end{fulllineitems}

\index{shape() (SliceGenerator.NrrdSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.NrrdSliceGenerator.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
Overrides the superclass to return the shape of the NRRD file.

\end{fulllineitems}

\index{slices() (SliceGenerator.NrrdSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.NrrdSliceGenerator.slices}\pysiglinewithargsret{\bfcode{slices}}{\emph{start=0}}{}
Slices are yielded one slice at a time from the memory mapped NRRD file.

\end{fulllineitems}


\end{fulllineitems}

\index{SliceGenerator (class in SliceGenerator)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.SliceGenerator}\pysiglinewithargsret{\strong{class }\code{SliceGenerator.}\bfcode{SliceGenerator}}{\emph{recon}}{}
Bases: \code{object}
\index{dtype() (SliceGenerator.SliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.SliceGenerator.dtype}\pysiglinewithargsret{\bfcode{dtype}}{}{}
The dtype method should return the datatype of the memory mapped numpy array

\end{fulllineitems}

\index{shape() (SliceGenerator.SliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.SliceGenerator.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
The shape method should return the shape of the memory mapped numpy array in x, y, z order.

\end{fulllineitems}

\index{slices() (SliceGenerator.SliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.SliceGenerator.slices}\pysiglinewithargsret{\bfcode{slices}}{}{}
The slices method should yield xy image slices from a memory mapped numpy array.

\end{fulllineitems}


\end{fulllineitems}

\index{TXMSliceGenerator (class in SliceGenerator)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TXMSliceGenerator}\pysiglinewithargsret{\strong{class }\code{SliceGenerator.}\bfcode{TXMSliceGenerator}}{\emph{recon}}{}
Bases: {\hyperref[SliceGenerator:SliceGenerator.SliceGenerator]{\code{SliceGenerator.SliceGenerator}}}

The TXMSliceGenerator class extends SliceGenerator, yielding slices from TXM file (Transmission X-ray Microscopy).

This generator has not been tested comprehensively, as we only have access to one TXM file for testing. It makes use
of the ctutils module (\href{https://github.com/waveform80/ctutils}{https://github.com/waveform80/ctutils})
\index{dtype() (SliceGenerator.TXMSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TXMSliceGenerator.dtype}\pysiglinewithargsret{\bfcode{dtype}}{}{}
Overrides the superclass to return the data type of the TXM file i.e. 8 bit/16 bit.

\end{fulllineitems}

\index{shape() (SliceGenerator.TXMSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TXMSliceGenerator.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
Overrides the superclass to return the shape of the TXM file.

\end{fulllineitems}

\index{slices() (SliceGenerator.TXMSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TXMSliceGenerator.slices}\pysiglinewithargsret{\bfcode{slices}}{\emph{start=0}}{}
Slices are yielded one slice at a time from the TXM file.

\end{fulllineitems}


\end{fulllineitems}

\index{TiffSliceGenerator (class in SliceGenerator)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffSliceGenerator}\pysiglinewithargsret{\strong{class }\code{SliceGenerator.}\bfcode{TiffSliceGenerator}}{\emph{recon}}{}
Bases: {\hyperref[SliceGenerator:SliceGenerator.SliceGenerator]{\code{SliceGenerator.SliceGenerator}}}

The TiffSliceGenerator class extends SliceGenerator, yielding slices from a folder of TIFFs. The method uses the
tifffile.py module, created by Christoph Gohlke.

This class is unlikely to ever be needed, as we should not receive folders of TIFFs from IMPC centres.
\index{dtype() (SliceGenerator.TiffSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffSliceGenerator.dtype}\pysiglinewithargsret{\bfcode{dtype}}{}{}
Overrides the superclass to return the data type of the TIFF files i.e. 8 bit/16 bit.

\end{fulllineitems}

\index{shape() (SliceGenerator.TiffSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffSliceGenerator.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
Overrides the superclass to return the shape of the TIFF files as a volume.

\end{fulllineitems}

\index{slices() (SliceGenerator.TiffSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffSliceGenerator.slices}\pysiglinewithargsret{\bfcode{slices}}{\emph{start=0}}{}
Slices are yielded one slice at a time from the list of TIFFs.

\end{fulllineitems}


\end{fulllineitems}

\index{TiffStackSliceGenerator (class in SliceGenerator)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffStackSliceGenerator}\pysiglinewithargsret{\strong{class }\code{SliceGenerator.}\bfcode{TiffStackSliceGenerator}}{\emph{recon}}{}
Bases: {\hyperref[SliceGenerator:SliceGenerator.SliceGenerator]{\code{SliceGenerator.SliceGenerator}}}

The TiffStackSliceGenerator class extends SliceGenerator, yielding slices from a single TIFF stack.

In the unlikely event that we receive a TIFF stack from an IMPC centre, this generator will slice it for resampling.
At present, TIFF stacks CANNOT be memory mampped, and will ne loaded into memory. The method uses the tifffile.py
module, created by Christoph Gohlke.
\index{dtype() (SliceGenerator.TiffStackSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffStackSliceGenerator.dtype}\pysiglinewithargsret{\bfcode{dtype}}{}{}
Overrides the superclass to return the data type of the TIFF stack i.e. 8 bit/16 bit.

\end{fulllineitems}

\index{shape() (SliceGenerator.TiffStackSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffStackSliceGenerator.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
Overrides the superclass to return the shape of the TIFF stack.

\end{fulllineitems}

\index{slices() (SliceGenerator.TiffStackSliceGenerator method)}

\begin{fulllineitems}
\phantomsection\label{SliceGenerator:SliceGenerator.TiffStackSliceGenerator.slices}\pysiglinewithargsret{\bfcode{slices}}{\emph{start=0}}{}
Slices are yielded one slice at a time from the TIFF stack.

\end{fulllineitems}


\end{fulllineitems}



\chapter{conversion module}
\label{conversion:conversion-module}\label{conversion:module-conversion}\label{conversion::doc}\index{conversion (module)}\index{decompress\_bz2() (in module conversion)}

\begin{fulllineitems}
\phantomsection\label{conversion:conversion.decompress_bz2}\pysiglinewithargsret{\code{conversion.}\bfcode{decompress\_bz2}}{\emph{bz2\_in}, \emph{decompressed\_out}}{}
The decompress\_bz2 method performs sequential decompression of bzipped files on disk.

If the bz2\_in path can be found, the file is open and read in chunks of \textasciitilde{}100 Mb at a time. Each chunk is then
decompressed, and written to the file specified by decompressed\_out. A progress bar is used to indicate how the
decompression is getting on.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{bz2\_in} -- path to bzipped file to be decompressed

\item {} 
\textbf{decompressed\_out} -- path to output file, which can already exist

\end{itemize}

\item[{Raises IOError}] \leavevmode
the decompressed file could not be found/opened

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_xtk\_nrrd() (in module conversion)}

\begin{fulllineitems}
\phantomsection\label{conversion:conversion.write_xtk_nrrd}\pysiglinewithargsret{\code{conversion.}\bfcode{write\_xtk\_nrrd}}{\emph{volume}, \emph{nrrd\_out}}{}
The write\_xtk\_nrrd method writes numpy arrays as IEV-ready NRRD files. It also works on memory mapped arrays.

IEV works using the X Toolkit (XTK), which is quite particular about the NRRD files it displays. This method ensures
that the NRRD headers are written appropriately, using nrrd.py by Maarten Everts
(\href{https://github.com/mhe/pynrrd/blob/master/nrrd.py}{https://github.com/mhe/pynrrd/blob/master/nrrd.py})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{volume} -- a numpy array in memory, or a memory mapped numpy array

\item {} 
\textbf{nrrd\_out} -- a file path to which the NRRD file is written

\end{itemize}

\item[{Raises IOError}] \leavevmode
unable to write file to disk

\end{description}\end{quote}

\end{fulllineitems}



\chapter{nrrd module}
\label{nrrd:nrrd-module}\label{nrrd:module-nrrd}\label{nrrd::doc}\index{nrrd (module)}
nrrd.py
An all-python (and numpy) implementation for reading and writing nrrd files.
See \href{http://teem.sourceforge.net/nrrd/format.html}{http://teem.sourceforge.net/nrrd/format.html} for the specification.

Copyright (c) 2011 Maarten Everts and David Hammond. See LICENSE.
\index{NrrdError}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.NrrdError}\pysigline{\strong{exception }\code{nrrd.}\bfcode{NrrdError}}
Bases: \code{exceptions.Exception}

Exceptions for Nrrd class.

\end{fulllineitems}

\index{parse\_nrrdvector() (in module nrrd)}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.parse_nrrdvector}\pysiglinewithargsret{\code{nrrd.}\bfcode{parse\_nrrdvector}}{\emph{inp}}{}
Parse a vector from a nrrd header, return a list.

\end{fulllineitems}

\index{parse\_optional\_nrrdvector() (in module nrrd)}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.parse_optional_nrrdvector}\pysiglinewithargsret{\code{nrrd.}\bfcode{parse\_optional\_nrrdvector}}{\emph{inp}}{}
Parse a vector from a nrrd header that can also be none.

\end{fulllineitems}

\index{read() (in module nrrd)}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.read}\pysiglinewithargsret{\code{nrrd.}\bfcode{read}}{\emph{filename}}{}
Read a nrrd file and return a tuple (data, header).

\end{fulllineitems}

\index{read\_data() (in module nrrd)}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.read_data}\pysiglinewithargsret{\code{nrrd.}\bfcode{read\_data}}{\emph{fields}, \emph{filehandle}, \emph{filename=None}}{}
Read the actual data into a numpy structure.

\end{fulllineitems}

\index{read\_header() (in module nrrd)}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.read_header}\pysiglinewithargsret{\code{nrrd.}\bfcode{read\_header}}{\emph{nrrdfile}}{}
Parse the fields in the nrrd header

nrrdfile can be any object which supports the iterator protocol and
returns a string each time its next() method is called — file objects and
list objects are both suitable. If csvfile is a file object, it must be
opened with the ‘b’ flag on platforms where that makes a difference
(e.g. Windows)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{read\PYGZus{}header}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NRRD0005}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{type: float}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dimension: 3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}type\PYGZsq{}: \PYGZsq{}float\PYGZsq{}, \PYGZsq{}dimension\PYGZsq{}: 3, \PYGZsq{}keyvaluepairs\PYGZsq{}: \PYGZob{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{read\PYGZus{}header}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NRRD0005}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my extra info:=my : colon\PYGZhy{}separated : values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}keyvaluepairs\PYGZsq{}: \PYGZob{}\PYGZsq{}my extra info\PYGZsq{}: \PYGZsq{}my : colon\PYGZhy{}separated : values\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}

\index{write() (in module nrrd)}

\begin{fulllineitems}
\phantomsection\label{nrrd:nrrd.write}\pysiglinewithargsret{\code{nrrd.}\bfcode{write}}{\emph{filename}, \emph{data}, \emph{options=\{\}}, \emph{separate\_header=False}}{}
Write the numpy data to a nrrd file. The nrrd header values to use are
inferred from from the data. Additional options can be passed in the
options dictionary. See the read() function for the structure of this
dictionary.

To set data samplings, use e.g. \emph{options{[}'spacings'{]} = {[}s1, s2, s3{]}} for
3d data with sampling deltas \emph{s1}, \emph{s2}, and \emph{s3} in each dimension.

\end{fulllineitems}



\chapter{resampler module}
\label{resampler:resampler-module}\label{resampler::doc}\label{resampler:module-resampler}\index{resampler (module)}
Resampler for the embryo pre-processing script.

This module performs resampling of images of arbitrary size, using a slice generator and memory mapped raw files.


\section{Requirements}
\label{resampler:requirements}\begin{itemize}
\item {} 
\href{http://docs.opencv.org/}{OpenCV 2.4.9}

\item {} 
\href{http://www.numpy.org}{Numpy 1.8.2}

\item {} 
\href{https://code.google.com/p/python-progressbar/}{python-progressbar 2.3}

\end{itemize}


\section{Examples}
\label{resampler:examples}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{resampler} \PYG{k+kn}{import} \PYG{n}{resample}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{SliceGenerator} \PYG{k+kn}{import} \PYG{n}{NrrdSliceGenerator}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{gen} \PYG{o}{=} \PYG{n}{NrrdSliceGenerator}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/path/to/file.nrrd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{resample}\PYG{p}{(}\PYG{n}{gen}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/path/to/rescaled.nrrd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}
\index{resample() (in module resampler)}

\begin{fulllineitems}
\phantomsection\label{resampler:resampler.resample}\pysiglinewithargsret{\code{resampler.}\bfcode{resample}}{\emph{slicegen}, \emph{scale}, \emph{nrrd\_path}}{}
The resample method takes a slice generator and scaling factor as arguments, resamples the image accordingly,
and writes it to disk as an IEV-ready NRRD file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{slicegen} -- a slice generator that provides xy slices of an image as two-dimensional numpy arrays

\item {} 
\textbf{scale} -- scaling factor for resampling, which should be \textless{} 1 for downscaling (e.g. 0.5)

\item {} 
\textbf{nrrd\_path} -- outfile NRRD containing extension

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{test module}
\label{test:module-test}\label{test::doc}\label{test:test-module}\index{test (module)}

\chapter{tifffile module}
\label{tifffile:module-tifffile}\label{tifffile:tifffile-module}\label{tifffile::doc}\index{tifffile (module)}
Read and write image data from and to TIFF files.
Image and meta-data can be read from TIFF, BigTIFF, OME-TIFF, STK, LSM, NIH,
ImageJ, MicroManager, FluoView, SEQ and GEL files.
Only a subset of the TIFF specification is supported, mainly uncompressed
and losslessly compressed 2**(0 to 6) bit integer, 16, 32 and 64-bit float,
grayscale and RGB(A) images, which are commonly used in bio-scientific imaging.
Specifically, reading JPEG/CCITT compressed image data or EXIF/IPTC/GPS/XMP
meta-data is not implemented. Only primary info records are read for STK,
FluoView, MicroManager, and NIH image formats.
TIFF, the Tagged Image File Format, is under the control of Adobe Systems.
BigTIFF allows for files greater than 4 GB. STK, LSM, FluoView, SEQ, GEL,
and OME-TIFF, are custom extensions defined by MetaMorph, Carl Zeiss
MicroImaging, Olympus, Media Cybernetics, Molecular Dynamics, and the Open
Microscopy Environment consortium respectively.
For command line usage run \code{python tifffile.py -{-}help}
:Author:
\begin{quote}

\href{http://www.lfd.uci.edu/~gohlke/}{Christoph Gohlke}
\end{quote}
\begin{quote}\begin{description}
\item[{Organization}] \leavevmode
Laboratory for Fluorescence Dynamics, University of California, Irvine

\item[{Version}] \leavevmode
2014.02.05

\end{description}\end{quote}


\section{Requirements}
\label{tifffile:requirements}\begin{itemize}
\item {} 
\href{http://www.python.org}{CPython 2.7 or 3.3}

\item {} 
\href{http://www.numpy.org}{Numpy 1.7}

\item {} 
\href{http://www.matplotlib.org}{Matplotlib 1.3}  (optional for plotting)

\item {} 
\href{http://www.lfd.uci.edu/~gohlke/}{Tifffile.c 2013.01.18}
(recommended for faster decoding of PackBits and LZW encoded strings)

\end{itemize}


\section{Notes}
\label{tifffile:notes}
The API is not stable yet and might change between revisions.
Tested on little-endian platforms only.
Other Python packages and modules for reading bio-scientific TIFF files:
* \href{http://luispedro.org/software/imread}{Imread}
* \href{http://code.google.com/p/pylibtiff}{PyLibTiff}
* \href{http://www.simpleitk.org}{SimpleITK}
* \href{https://launchpad.net/pylsm}{PyLSM}
* \href{http://pymca.sourceforge.net/}{PyMca.TiffIO.py}
* \href{http://www.bioimagexd.net/}{BioImageXD.Readers}
* \href{http://cellcognition.org/}{Cellcognition.io}
* \href{http://www.cellprofiler.org/}{CellProfiler.bioformats}
Acknowledgements
----------------
*  Egor Zindy, University of Manchester, for cz\_lsm\_scan\_info specifics.
*  Wim Lewis for a bug fix and some read\_cz\_lsm functions.
*  Hadrien Mary for help on reading MicroManager files.
References
----------
(1) TIFF 6.0 Specification and Supplements. Adobe Systems Incorporated.
\begin{quote}

\href{http://partners.adobe.com/public/developer/tiff/}{http://partners.adobe.com/public/developer/tiff/}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
TIFF File Format FAQ. \href{http://www.awaresystems.be/imaging/tiff/faq.html}{http://www.awaresystems.be/imaging/tiff/faq.html}

\item {} 
MetaMorph Stack (STK) Image File Format.
\href{http://support.meta.moleculardevices.com/docs/t10243.pdf}{http://support.meta.moleculardevices.com/docs/t10243.pdf}

\item {} 
File Format Description - LSM 5xx Release 2.0.
\href{http://ibb.gsf.de/homepage/karsten.rodenacker/IDL/Lsmfile.doc}{http://ibb.gsf.de/homepage/karsten.rodenacker/IDL/Lsmfile.doc}

\item {} 
BioFormats. \href{http://www.loci.wisc.edu/ome/formats.html}{http://www.loci.wisc.edu/ome/formats.html}

\item {} 
The OME-TIFF format.
\href{http://www.openmicroscopy.org/site/support/file-formats/ome-tiff}{http://www.openmicroscopy.org/site/support/file-formats/ome-tiff}

\item {} 
TiffDecoder.java
\href{http://rsbweb.nih.gov/ij/developer/source/ij/io/TiffDecoder.java.html}{http://rsbweb.nih.gov/ij/developer/source/ij/io/TiffDecoder.java.html}

\item {} 
UltraQuant(r) Version 6.0 for Windows Start-Up Guide.
\href{http://www.ultralum.com/images\%20ultralum/pdf/UQStart\%20Up\%20Guide.pdf}{http://www.ultralum.com/images\%20ultralum/pdf/UQStart\%20Up\%20Guide.pdf}

\item {} 
Micro-Manager File Formats.
\href{http://www.micro-manager.org/wiki/Micro-Manager\_File\_Formats}{http://www.micro-manager.org/wiki/Micro-Manager\_File\_Formats}

\end{enumerate}


\section{Examples}
\label{tifffile:examples}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{301}\PYG{p}{,} \PYG{l+m+mi}{219}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{imsave}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{image} \PYG{o}{=} \PYG{n}{imread}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{assert} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{n}{image} \PYG{o}{==} \PYG{n}{data}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tif} \PYG{o}{=} \PYG{n}{TiffFile}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{images} \PYG{o}{=} \PYG{n}{tif}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{image0} \PYG{o}{=} \PYG{n}{tif}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{page} \PYG{o+ow}{in} \PYG{n}{tif}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{tag} \PYG{o+ow}{in} \PYG{n}{page}\PYG{o}{.}\PYG{n}{tags}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{t} \PYG{o}{=} \PYG{n}{tag}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{tag}\PYG{o}{.}\PYG{n}{value}
\PYG{g+gp}{... }    \PYG{n}{image} \PYG{o}{=} \PYG{n}{page}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{page}\PYG{o}{.}\PYG{n}{is\PYGZus{}rgb}\PYG{p}{:} \PYG{k}{pass}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{page}\PYG{o}{.}\PYG{n}{is\PYGZus{}palette}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{t} \PYG{o}{=} \PYG{n}{page}\PYG{o}{.}\PYG{n}{color\PYGZus{}map}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{page}\PYG{o}{.}\PYG{n}{is\PYGZus{}stk}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{t} \PYG{o}{=} \PYG{n}{page}\PYG{o}{.}\PYG{n}{mm\PYGZus{}uic\PYGZus{}tags}\PYG{o}{.}\PYG{n}{number\PYGZus{}planes}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{page}\PYG{o}{.}\PYG{n}{is\PYGZus{}lsm}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{t} \PYG{o}{=} \PYG{n}{page}\PYG{o}{.}\PYG{n}{cz\PYGZus{}lsm\PYGZus{}info}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tif}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}
\index{imsave() (in module tifffile)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.imsave}\pysiglinewithargsret{\code{tifffile.}\bfcode{imsave}}{\emph{filename}, \emph{data}, \emph{photometric=None}, \emph{planarconfig=None}, \emph{resolution=None}, \emph{description=None}, \emph{software='tifffile.py'}, \emph{byteorder=None}, \emph{bigtiff=False}, \emph{compress=0}, \emph{extratags=()}}{}
Write image data to TIFF file.
Image data are written in one stripe per plane.
Dimensions larger than 2 or 3 (depending on photometric mode and
planar configuration) are flattened and saved as separate pages.
The `sample\_format' and `bits\_per\_sample' TIFF tags are derived from
the data type.
Parameters
----------
filename : str
\begin{quote}

Name of file to write.
\end{quote}
\begin{description}
\item[{data}] \leavevmode{[}array\_like{]}
Input image. The last dimensions are assumed to be image height,
width, and samples.

\item[{photometric}] \leavevmode{[}\{`minisblack', `miniswhite', `rgb'\}{]}
The color space of the image data.
By default this setting is inferred from the data shape.

\item[{planarconfig}] \leavevmode{[}\{`contig', `planar'\}{]}
Specifies if samples are stored contiguous or in separate planes.
By default this setting is inferred from the data shape.
`contig': last dimension contains samples.
`planar': third last dimension contains samples.

\item[{resolution}] \leavevmode{[}(float, float) or ((int, int), (int, int)){]}
X and Y resolution in dots per inch as float or rational numbers.

\item[{description}] \leavevmode{[}str{]}
The subject of the image. Saved with the first page only.

\item[{software}] \leavevmode{[}str{]}
Name of the software used to create the image.
Saved with the first page only.

\item[{byteorder}] \leavevmode{[}\{`\textless{}', `\textgreater{}'\}{]}
The endianness of the data in the file.
By default this is the system's native byte order.

\item[{bigtiff}] \leavevmode{[}bool{]}
If True, the BigTIFF format is used.
By default the standard TIFF format is used for data less than 2000 MB.

\item[{compress}] \leavevmode{[}int{]}
Values from 0 to 9 controlling the level of zlib compression.
If 0, data are written uncompressed (default).

\item[{extratags: sequence of tuples}] \leavevmode
Additional tags as {[}(code, dtype, count, value, writeonce){]}.
code : int
\begin{quote}

The TIFF tag Id.
\end{quote}
\begin{description}
\item[{dtype}] \leavevmode{[}str{]}
Data type of items in \emph{value} in Python struct format.
One of B, s, H, I, 2I, b, h, i, f, d, Q, or q.

\item[{count}] \leavevmode{[}int{]}
Number of data values. Not used for string values.

\item[{value}] \leavevmode{[}sequence{]}
\emph{Count} values compatible with \emph{dtype}.

\item[{writeonce}] \leavevmode{[}bool{]}
If True, the tag is written to the first page only.

\end{description}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{301}\PYG{p}{,} \PYG{l+m+mi}{219}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{float32}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{0.5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{imsave}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{compress}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{301}\PYG{p}{,} \PYG{l+m+mi}{219}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{uint8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{127}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{value} \PYG{o}{=} \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZcb{}}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{imsave}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{extratags}\PYG{o}{=}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{270}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{imread() (in module tifffile)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.imread}\pysiglinewithargsret{\code{tifffile.}\bfcode{imread}}{\emph{files}, \emph{*args}, \emph{**kwargs}}{}
Return image data from TIFF file(s) as numpy array.
The first image series is returned if no arguments are provided.
Parameters
----------
files : str or list
\begin{quote}

File name, glob pattern, or list of file names.
\end{quote}
\begin{description}
\item[{key}] \leavevmode{[}int, slice, or sequence of page indices{]}
Defines which pages to return as array.

\item[{series}] \leavevmode{[}int{]}
Defines which series of pages in file to return as array.

\item[{multifile}] \leavevmode{[}bool{]}
If True (default), OME-TIFF data may include pages from multiple files.

\item[{pattern}] \leavevmode{[}str{]}
Regular expression pattern that matches axes names and indices in
file names.

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im} \PYG{o}{=} \PYG{n}{imread}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(256, 256, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ims} \PYG{o}{=} \PYG{n}{imread}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ims}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(2, 256, 256, 4)}
\end{Verbatim}

\end{fulllineitems}

\index{imshow() (in module tifffile)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.imshow}\pysiglinewithargsret{\code{tifffile.}\bfcode{imshow}}{\emph{data}, \emph{title=None}, \emph{vmin=0}, \emph{vmax=None}, \emph{cmap=None}, \emph{bitspersample=None}, \emph{photometric='rgb'}, \emph{interpolation='nearest'}, \emph{dpi=96}, \emph{figure=None}, \emph{subplot=111}, \emph{maxdim=8192}, \emph{**kwargs}}{}
Plot n-dimensional images using matplotlib.pyplot.
Return figure, subplot and plot axis.
Requires pyplot already imported \code{from matplotlib import pyplot}.
Parameters
----------
bitspersample : int or None
\begin{quote}

Number of bits per channel in integer RGB images.
\end{quote}
\begin{description}
\item[{photometric}] \leavevmode{[}\{`miniswhite', `minisblack', `rgb', or `palette'\}{]}
The color space of the image data.

\item[{title}] \leavevmode{[}str{]}
Window and subplot title.

\item[{figure}] \leavevmode{[}matplotlib.figure.Figure (optional).{]}
Matplotlib to use for plotting.

\item[{subplot}] \leavevmode{[}int{]}
A matplotlib.pyplot.subplot axis.

\item[{maxdim}] \leavevmode{[}int{]}
maximum image size in any dimension.

\item[{kwargs}] \leavevmode{[}optional{]}
Arguments for matplotlib.pyplot.imshow.

\end{description}

\end{fulllineitems}

\index{TiffFile (class in tifffile)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile}\pysiglinewithargsret{\strong{class }\code{tifffile.}\bfcode{TiffFile}}{\emph{arg}, \emph{name=None}, \emph{multifile=False}}{}
Bases: \code{object}

Read image and meta-data from TIFF, STK, LSM, and FluoView files.
TiffFile instances must be closed using the close method, which is
automatically called when using the `with' statement.
Attributes
----------
pages : list
\begin{quote}

All TIFF pages in file.
\end{quote}
\begin{description}
\item[{series}] \leavevmode{[}list of Records(shape, dtype, axes, TiffPages){]}
TIFF pages with compatible shapes and types.

\item[{micromanager\_metadata: dict}] \leavevmode
Extra MicroManager non-TIFF metadata in the file, if exists.

\end{description}

All attributes are read-only.
Examples
--------
\textgreater{}\textgreater{}\textgreater{} tif = TiffFile(`test.tif')
... try:
...     images = tif.asarray()
... except Exception as e:
...     print(e)
... finally:
...     tif.close()
\index{asarray() (tifffile.TiffFile method)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.asarray}\pysiglinewithargsret{\bfcode{asarray}}{\emph{key=None}, \emph{series=None}, \emph{memmap=False}}{}
Return image data of multiple TIFF pages as numpy array.
By default the first image series is returned.
Parameters
----------
key : int, slice, or sequence of page indices
\begin{quote}

Defines which pages to return as array.
\end{quote}
\begin{description}
\item[{series}] \leavevmode{[}int{]}
Defines which series of pages to return as array.

\item[{memmap}] \leavevmode{[}bool{]}
If True, use numpy.memmap to read arrays from file if possible.

\end{description}

\end{fulllineitems}

\index{close() (tifffile.TiffFile method)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.close}\pysiglinewithargsret{\bfcode{close}}{}{}
Close open file handle(s).

\end{fulllineitems}

\index{fstat (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.fstat}\pysigline{\bfcode{fstat}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_bigtiff (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_bigtiff}\pysigline{\bfcode{is\_bigtiff}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_fluoview (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_fluoview}\pysigline{\bfcode{is\_fluoview}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_imagej (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_imagej}\pysigline{\bfcode{is\_imagej}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_lsm (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_lsm}\pysigline{\bfcode{is\_lsm}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_mdgel (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_mdgel}\pysigline{\bfcode{is\_mdgel}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_mediacy (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_mediacy}\pysigline{\bfcode{is\_mediacy}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_micromanager (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_micromanager}\pysigline{\bfcode{is\_micromanager}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_nih (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_nih}\pysigline{\bfcode{is\_nih}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_ome (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_ome}\pysigline{\bfcode{is\_ome}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_palette (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_palette}\pysigline{\bfcode{is\_palette}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_rgb (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_rgb}\pysigline{\bfcode{is\_rgb}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{is\_stk (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.is_stk}\pysigline{\bfcode{is\_stk}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}

\index{series (tifffile.TiffFile attribute)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffFile.series}\pysigline{\bfcode{series}}
Lazy object attribute whose value is computed on first access.

\end{fulllineitems}


\end{fulllineitems}

\index{TiffSequence (class in tifffile)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffSequence}\pysiglinewithargsret{\strong{class }\code{tifffile.}\bfcode{TiffSequence}}{\emph{files}, \emph{imread=\textless{}class `tifffile.TiffFile'\textgreater{}}, \emph{pattern='axes'}}{}
Bases: \code{object}

Sequence of image files.
Properties
----------
files : list
\begin{quote}

List of file names.
\end{quote}
\begin{description}
\item[{shape}] \leavevmode{[}tuple{]}
Shape of image sequence.

\item[{axes}] \leavevmode{[}str{]}
Labels of axes in shape.

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ims} \PYG{o}{=} \PYG{n}{TiffSequence}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.oif.files/*.tif}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ims} \PYG{o}{=} \PYG{n}{ims}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ims}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(2, 100, 256, 256)}
\end{Verbatim}
\index{asarray() (tifffile.TiffSequence method)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffSequence.asarray}\pysiglinewithargsret{\bfcode{asarray}}{\emph{*args}, \emph{**kwargs}}{}
Read image data from all files and return as single numpy array.
Raise IndexError if image shapes don't match.

\end{fulllineitems}

\index{close() (tifffile.TiffSequence method)}

\begin{fulllineitems}
\phantomsection\label{tifffile:tifffile.TiffSequence.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{conversion}}, \pageref{conversion:module-conversion}
\indexspace
\bigletter{e}
\item {\texttt{EmbryoPreprocess}}, \pageref{EmbryoPreprocess:module-EmbryoPreprocess}
\indexspace
\bigletter{n}
\item {\texttt{nrrd}}, \pageref{nrrd:module-nrrd}
\indexspace
\bigletter{r}
\item {\texttt{resampler}}, \pageref{resampler:module-resampler}
\indexspace
\bigletter{s}
\item {\texttt{SliceGenerator}}, \pageref{SliceGenerator:module-SliceGenerator}
\indexspace
\bigletter{t}
\item {\texttt{test}}, \pageref{test:module-test}
\item {\texttt{tifffile}}, \pageref{tifffile:module-tifffile}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
